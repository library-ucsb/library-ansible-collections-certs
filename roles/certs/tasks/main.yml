---
# tasks file for roles/certs

- name: create root certificate storage directory
  file:
    path: "{{ certs_global.cert_storage_path }}"
    state: directory
    mode: 0700


- name: create subdirectory for each certificate
  file:
    path: "{{ certs_global.cert_storage_path }}/{{ item.name }}"
    state: directory
  loop: "{{ certificates }}"


- name: generate openssl private keys
  community.crypto.openssl_privatekey:
    path: "{{ certs_global.cert_storage_path }}/{{ item.name }}/{{ item.cert.cn }}.private.pem"
    size: "{{ item.key_size | default(certs_global.key_size) }}"
    passphrase: "{{ item.passphrase | default(omit) }}"
    cipher: "{{ item.cipher | default(omit) }}"
    backup: yes
  loop: "{{ certificates }}"


- name: generate certificate signing requests
  community.crypto.openssl_csr:
    path: "{{ certs_global.cert_storage_path }}/{{ item.name }}/{{ item.cert.cn }}.csr"
    privatekey_path: "{{ certs_global.cert_storage_path }}/{{ item.name }}/{{ item.cert.cn }}.private.pem"
    privatekey_passphrase: "{{ item.passphrase | default(omit) }}"
    subject_alt_name: "{{ item.cert.sans | map('regex_replace', '^', 'DNS:') | list }}"
    common_name: "{{ item.cert.cn }}"
    email_address: "{{ certs_global.email }}"
    organizational_unit_name: "{{ certs_global.common.certificate.ou }}"
    country_name: "{{ certs_global.common.certificate.country }}"
    locality_name: "{{ certs_global.common.certificate.locality }}"
    state_or_province_name: "{{ certs_global.common.certificate.state }}"
  loop: "{{ certificates }}"



### Create a dict of the certs that have a private key.

# loop over the provided dict in the 'certificates' variable with the filter requirement that the private key file must exist.  
# For those that do exist, we establish the vars we need going forward with with future tasks.  The results are then placed into
# the 'signed_certs' local variable.
- name: check for a pkcs12 cert
  set_fact:
    certificate:
    - path: "{{ certs_global.cert_storage_path }}/{{ item.name }}/{{ item.cert.cn }}.pkcs12"
      privatekey_path: "{{ certs_global.cert_storage_path }}/{{ item.name }}/{{ item.cert.cn }}.private.pem"
      privatekey_passphrase: "{{ item.passphrase | default(omit) }}"
      certificate_path: "{{ certs_global.cert_storage_path }}/{{ item.name }}/{{ item.cert.cn }}.certificate.pem"
      other_certificates: "{{ certs_global.cert_storage_path }}/{{ item.name }}/ca.pem"
      name: "{{ item.name }}"
      cert: "{{ item.cert }}"
  loop: "{{ certificates }}"
  register: signed_certs
  when: "'{{ certs_global.cert_storage_path }}/{{ item.name }}/{{ item.cert.cn }}.certificate.pem' is exists"

- name: debug printout of signed cert dict
  debug:
    msg: "{{ item }}"
  loop: "{{ signed_certs.results }}"
  when: item is not skipped


## PKCS12

# Taking the 'signed_certs' variable defined in a previous task, loop over the structure to define the required
# values to generate a pkcs12 file, which is a combo of our ca, out private key, and our signed cert.
- name: generate pkcs#12 file
  community.crypto.openssl_pkcs12:
    action: export
    friendly_name: "{{ item.item.name }}"
    path: "{{ certs_global.cert_storage_path }}/{{ item.item.name }}/{{ item.item.cert.cn }}.pkcs12"
    privatekey_path: "{{ certs_global.cert_storage_path }}/{{ item.item.name }}/{{ item.item.cert.cn }}.private.pem"
    privatekey_passphrase: "{{ item.item.passphrase | default(omit) }}"
    certificate_path: "{{ certs_global.cert_storage_path }}/{{ item.item.name }}/{{ item.item.cert.cn }}.certificate.pem"
    other_certificates: "{{ certs_global.cert_storage_path }}/{{ item.item.name }}/ca.pem"
    state: present
  loop: "{{ signed_certs.results }}"
  when: item is not skipped



### Java Keystore


- name: create haproxy cert ( private key > signed certificate > intermediate certificate )
  community.crypto.openssl_x509_certificate:
    path: "{{ certs_global.cert_storage_path }}/{{ item.item.name }}/{{ item.item.cert.cn }}.combined.cer"
    csr_path: "{{ certs_global.cert_storage_path }}/{{ item.name }}/{{ item.cert.cn }}.csr"
    provider: ownca
    ownca_path:
    ownca_privatekey_path:
    
  loop: "{{ signed_certs.results }}"
  when: item is not skipped
